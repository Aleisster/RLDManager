using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace RLDManager
{
    public class RLD
    {
        private bool Status = false;
        private byte[] Script;
        public Encoding SJIS = Encoding.GetEncoding(932);
        uint[] Offsets;
        uint[] Lenghts;
        public RLD(byte[] Script) {
            this.Script = Script;
        }

        public string[] Import() {
            if (!Status) {
                XOR(ref Script);
                System.IO.File.WriteAllBytes("dump.rld", Script);
                Status = true;
            }
            Offsets = new uint[0];
            for (uint i = 0; i < Script.Length; i++) {
                Result Info = Scan(i);
                if (!Info.Valid)
                    continue;

                //Save offset
                Array.Resize(ref Offsets, Offsets.Length + 1);
                Offsets[Offsets.Length - 1] = Info.StrIndx;

            }
            //Initialize Variables
            string[] Strs = new string[Offsets.Length];
            Lenghts = new uint[Offsets.Length];

            for (int i = 0; i < Strs.Length; i++) {
                //Initialize String Variables
                byte[] Buff = new byte[0];
                uint Pos = Offsets[i];

                //Copy String
                while (Script[Pos] != 0x00) {
                    Array.Resize(ref Buff, Buff.Length + 1);
                    Buff[Buff.Length - 1] = Script[Pos++];
                }

                //Save String and Lenght
                Strs[i] = SJIS.GetString(Buff);
                Lenghts[i] = (uint)Buff.LongLength;
            }
            return Strs;
        }

        public byte[] Export(string[] Strings) {
            if (Strings.Length != Offsets.Length)
                throw new Exception("You Can't add new strings.");
            byte[] OutScript = new byte[Script.Length];
            Script.CopyTo(OutScript, 0);
            //Reverse Replace to don't need update offsets after a change.
            for (int i = Offsets.Length - 1; i >= 0; i--) {
                uint POS = Offsets[i];
                uint LEN = Lenghts[i];

                //Get Content Before the string
                byte[] Bef = GetRegion(OutScript, 0, POS);

                //Compile String
                byte[] Str = SJIS.GetBytes(Strings[i]);

                //Get Content After the string
                byte[] Aft = GetRegion(OutScript, POS + LEN, (uint)OutScript.LongLength - (POS + LEN));

                //Resize OutScript
                OutScript = new byte[Bef.LongLength + Aft.LongLength + Str.LongLength];

                //Merge Data
                Bef.CopyTo(OutScript, 0);
                Str.CopyTo(OutScript, Bef.LongLength);
                Aft.CopyTo(OutScript, Bef.LongLength + Str.LongLength);
            }
            //Encrypt and Return
            XOR(ref OutScript);
            return OutScript;
        }

        private byte[] GetRegion(byte[] From, uint Start, uint Lenght) {
            byte[] To = new byte[Lenght];
            for (uint i = Start; i - Start < Lenght; i++)
                To[i - Start] = From[i];
            return To;
        }

        private Result Scan(uint Pos) {
            Result rst = new Result() {
                Valid = false
            };
            if (Pos + 6 < Script.Length && Script[Pos] == 0xFF && Script[Pos+1] == 0xFF) {
                if (Script[Pos + 2] == 0x2A && Script[Pos + 3] == 0x00) {
                    rst.StrIndx = Pos + 4;
                    rst.Valid = IsAscii(Script[rst.StrIndx]) && IsAscii(Script[rst.StrIndx+1]);
                }
            }
            return rst;
        }

        private bool IsAscii(byte b) {
            return b >= 0x20 && b <= 0x7F;
        }
        public void XOR(ref byte[] Content) {
            /*
             * This Encryption is based on 4 Bytes blocks
             * and the position of this block, srry if looks confuse
             * And finally is just a XOR, don't need Encryption Algorithm ^^
             */

           uint Key = 0x39AA8BA0;//Princess Evangile
            uint BlockCount = (uint)Content.Length;

            if (BlockCount > 0xFFCF)
                BlockCount = 0xFFCF;

            BlockCount -= (BlockCount % 4);

            for (uint i = 0x10, ri = 0; i < BlockCount; i += 4, ri++) {
                uint enc = GetDW(Content, i);
                uint tmp = GetDW(Keys, (ri & 0xFF) * 4) ^ Key;
                SetDWAt(ref Content, i, tmp ^ enc);
            }
        }

        struct Result {
            internal bool Valid;
            internal uint StrIndx;
        }
        
        private readonly byte[] Keys = new byte[]{
         #region PrincessEvangile
    0xB9, 0xF9, 0xF2, 0x68, 0xA7, 0x31, 0x4A, 0x4D, 0x07, 0x97, 0x58, 0xCF, 0x31, 0x9B, 0xDE, 0xAD,
    0xAC, 0x9D, 0x1D, 0x9F, 0x52, 0x84, 0x56, 0x24, 0x5F, 0x02, 0x9A, 0x1A, 0x06, 0xAD, 0x03, 0x44,
    0xE4, 0x32, 0xC0, 0x66, 0xBF, 0xD0, 0x86, 0xF4, 0xF3, 0xF0, 0xE0, 0xCE, 0x61, 0x17, 0x62, 0xF1,
    0xBC, 0x97, 0x58, 0x38, 0xDD, 0x78, 0x38, 0x3E, 0x5E, 0xB5, 0xBD, 0x1F, 0x2E, 0xAD, 0x8A, 0xEF,
    0xF1, 0xB4, 0xBA, 0x4F, 0x97, 0x59, 0x24, 0xF4, 0x17, 0x87, 0xE6, 0x30, 0x74, 0x31, 0x62, 0xC9,
    0x83, 0x75, 0x02, 0xDD, 0x88, 0xB5, 0x54, 0x9E, 0x16, 0xBB, 0x07, 0x18, 0x9F, 0xBD, 0xD6, 0x85,
    0x49, 0xA8, 0x23, 0x06, 0xA1, 0xA4, 0xB4, 0xE7, 0x0F, 0x8A, 0xDD, 0x52, 0xD2, 0x41, 0x79, 0x76,
    0x32, 0xB4, 0x8D, 0x99, 0x93, 0x32, 0x51, 0xE6, 0xE1, 0x4E, 0x19, 0x19, 0x48, 0xE6, 0x0A, 0x59,
    0x6A, 0xD0, 0x0F, 0xE0, 0x1D, 0xCE, 0xD3, 0xF9, 0x3C, 0xD3, 0x0F, 0x21, 0x87, 0xE4, 0x2A, 0xC0,
    0x44, 0xF0, 0xDA, 0x51, 0xDD, 0xA8, 0x09, 0xC1, 0xB7, 0xBC, 0x85, 0xA0, 0x78, 0x94, 0xAB, 0x97,
    0x5F, 0x4E, 0x79, 0xBF, 0x99, 0x08, 0x71, 0x40, 0x4B, 0xC3, 0xED, 0xF0, 0x20, 0x2C, 0xC1, 0x26,
    0xA6, 0x8C, 0x36, 0xF2, 0x78, 0x73, 0x67, 0xEC, 0xC9, 0xC0, 0x69, 0xDE, 0xA1, 0x40, 0x03, 0x80,
    0xE3, 0x4A, 0x49, 0x7D, 0xCA, 0xA9, 0xE6, 0x87, 0xC5, 0xEC, 0xD0, 0x45, 0x7F, 0xFC, 0x96, 0xD6,
    0xD8, 0x58, 0x4F, 0x65, 0x64, 0x33, 0x4D, 0xE1, 0xFB, 0xEA, 0xCC, 0xA6, 0x6D, 0x19, 0x30, 0x57,
    0x80, 0x27, 0xAC, 0x0F, 0x42, 0x13, 0x2F, 0xE9, 0xF9, 0x75, 0x1B, 0xFB, 0xF7, 0xE5, 0xD1, 0xDF,
0xC1, 0xDF, 0xDB, 0x74, 0x97, 0x42, 0xBC, 0xFE, 0x66, 0x5B, 0xF5, 0x7B, 0xF5, 0xD6, 0xB9, 0x01,
0x79, 0x24, 0x95, 0x74, 0x2A, 0x42, 0x5D, 0x24, 0xF3, 0x68, 0x3C, 0xB8, 0x88, 0x57, 0x42, 0x7F,
0xAF, 0x5C, 0x0D, 0xB4, 0xB8, 0x70, 0x02, 0xB2, 0x59, 0x1A, 0x4A, 0x22, 0x1A, 0x04, 0xC3, 0xB5,
0xC2, 0xA3, 0xA2, 0x50, 0xD2, 0x1D, 0x30, 0xFE, 0x6E, 0x24, 0x08, 0xC7, 0x4F, 0x10, 0xE3, 0xBE,
0x01, 0x0E, 0x80, 0xF9, 0x11, 0xAD, 0x98, 0x9C, 0x72, 0x17, 0x2F, 0x6D, 0xDC, 0xBA, 0x6E, 0x20,
0x50, 0x0A, 0xB7, 0x02, 0x38, 0x2E, 0x8C, 0x8C, 0x44, 0x28, 0x6A, 0x04, 0x6D, 0x1D, 0x76, 0x19,
0x0C, 0x5C, 0xCD, 0xCC, 0x35, 0x0B, 0x28, 0x09, 0x1A, 0x86, 0xDD, 0xC6, 0xE7, 0x85, 0x17, 0xCB,
0x0C, 0xA1, 0xE0, 0xE1, 0x5A, 0xEB, 0xDE, 0x22, 0x5A, 0x79, 0x02, 0x29, 0x49, 0x58, 0x69, 0xAB,
0x03, 0x88, 0x22, 0xDB, 0xC8, 0x7B, 0x89, 0xFE, 0x62, 0x61, 0x81, 0x46, 0xD1, 0xD5, 0xF7, 0x8D,
0x92, 0x78, 0x33, 0xDA, 0x41, 0xBC, 0x86, 0x58, 0x39, 0x68, 0x35, 0x87, 0xDE, 0x3F, 0x35, 0x04,
0x2D, 0x22, 0x31, 0x52, 0x96, 0xD1, 0x1A, 0xFB, 0x9A, 0x42, 0x0F, 0xF9, 0x20, 0x6B, 0x21, 0xFA,
0xD3, 0x85, 0x2F, 0x65, 0x58, 0x33, 0x9B, 0x8D, 0xA8, 0xE6, 0xAD, 0x84, 0xBF, 0x06, 0x03, 0xF7,
0x0A, 0x95, 0x6A, 0x65, 0xD8, 0x0C, 0xC7, 0xF2, 0xD1, 0x20, 0x2C, 0x6A, 0x47, 0x00, 0x99, 0x88,
0xCC, 0xE1, 0x09, 0xFB, 0x27, 0xB8, 0x57, 0x4A, 0x3B, 0xF2, 0x15, 0x69, 0x01, 0x18, 0xC4, 0xC0,
0xEE, 0x83, 0x03, 0xFB, 0x0C, 0x2E, 0x8B, 0x64, 0xC5, 0x55, 0x23, 0x01, 0x29, 0xBC, 0x3C, 0xDE,
0x9D, 0x8D, 0x63, 0xCD, 0x9D, 0x22, 0x0E, 0x5E, 0x40, 0x88, 0xBD, 0x11, 0x58, 0x84, 0x40, 0x88,
0xED, 0x5D, 0x36, 0x47, 0xBF, 0xDD, 0xBF, 0x45, 0x57, 0xC5, 0x83, 0x3F, 0x52, 0xA1, 0xB8, 0x76,
0x36, 0xB6, 0x10, 0x1C, 0xEB, 0xC4, 0x95, 0x90, 0x53, 0xAF, 0x74, 0x5F, 0xF6, 0xE8, 0xD4, 0x9E,
0x08, 0xBB, 0x1A, 0xBA, 0x38, 0xDC, 0x1E, 0xD2, 0x37, 0xBF, 0x48, 0xC2, 0xAA, 0x63, 0x64, 0xF4,
0x22, 0x5C, 0x13, 0xE2, 0x0E, 0x2D, 0xB1, 0x06, 0x40, 0x4B, 0x93, 0x52, 0x92, 0xB3, 0xE1, 0x67,
0xAD, 0x84, 0xD2, 0x1E, 0x66, 0xA7, 0xF8, 0x39, 0xF6, 0xD5, 0xA4, 0xBA, 0x24, 0x28, 0xB9, 0x0B,
0xE2, 0x3E, 0xE8, 0x5A, 0x6B, 0x76, 0x48, 0x62, 0xCC, 0xD0, 0xAB, 0xAA, 0x12, 0xAC, 0x8F, 0xA9,
0x24, 0x5B, 0xE7, 0x21, 0xF6, 0x59, 0xBF, 0xF0, 0xFD, 0x11, 0x99, 0x23, 0x7C, 0x61, 0x18, 0x11,
0x02, 0x7E, 0xF9, 0x7C, 0xDB, 0x95, 0xB3, 0x8B, 0x89, 0xEB, 0x21, 0xE1, 0xBB, 0x67, 0xA3, 0x66,
0x0C, 0xFA, 0x3B, 0x52, 0xF0, 0x90, 0xB7, 0x40, 0xD9, 0xF8, 0x3F, 0x5D, 0xF1, 0x6A, 0x05, 0x9E,
0x40, 0x8B, 0xD4, 0xB9, 0xA1, 0x5F, 0x44, 0x19, 0xD1, 0x72, 0x35, 0x17, 0xB2, 0x0C, 0x4A, 0x92,
0x3D, 0x72, 0xA5, 0x4A, 0x2E, 0x64, 0xC8, 0xA3, 0x3A, 0xCC, 0x66, 0xCD, 0xF2, 0x48, 0xA8, 0x3F,
0xB1, 0x25, 0x23, 0xB3, 0x3D, 0x76, 0xC8, 0xE9, 0x38, 0x42, 0x5B, 0x22, 0x12, 0x99, 0x7F, 0x41,
0xD2, 0x69, 0x09, 0x67, 0x7C, 0x07, 0x44, 0x10, 0xCD, 0x56, 0xE6, 0xE9, 0x29, 0x1D, 0x53, 0x91,
0x8A, 0x1A, 0xA6, 0x66, 0x49, 0xCA, 0x26, 0x56, 0x40, 0xD1, 0x9D, 0x41, 0xB1, 0x0D, 0xE6, 0x90,
0x6C, 0xB6, 0xE5, 0x33, 0xA3, 0xB2, 0x0C, 0x1E, 0x6F, 0x33, 0x0F, 0xCA, 0xAA, 0x82, 0xAE, 0x33,
0x41, 0x49, 0xB6, 0xC0, 0x17, 0x8F, 0x8B, 0xB8, 0x4D, 0xC4, 0xEE, 0xB6, 0xCE, 0xA1, 0xB0, 0x53,
0x6D, 0xF9, 0x93, 0x36, 0x36, 0xA2, 0x8F, 0x52, 0x0B, 0x35, 0x7C, 0x00, 0xD4, 0xC4, 0x7C, 0x9A,
0x78, 0x56, 0x9F, 0x25, 0x6D, 0x6F, 0xDD, 0x66, 0xC3, 0xE0, 0x5F, 0x78, 0x84, 0x9D, 0xC1, 0xA3,
0x46, 0x3B, 0x74, 0x14, 0x34, 0x11, 0xA1, 0x80, 0xE5, 0x00, 0xD0, 0x8A, 0xB7, 0x17, 0xB4, 0x88,
0x7B, 0x2C, 0xFF, 0x87, 0x76, 0xDA, 0x9E, 0xB1, 0x78, 0x3B, 0x6A, 0x22, 0x75, 0x05, 0xA2, 0x7D,
0xC9, 0x34, 0x11, 0x37, 0x2A, 0x7B, 0xF3, 0x6D, 0x92, 0x2D, 0x92, 0xF4, 0xED, 0x03, 0x47, 0x59,
0x6B, 0x69, 0x7D, 0xFB, 0x3E, 0x85, 0x06, 0x17, 0x64, 0x22, 0xE9, 0x25, 0x2D, 0xC2, 0x73, 0x0D,
0x3A, 0x5B, 0x88, 0x21, 0xB0, 0xA4, 0x0B, 0xF9, 0xC9, 0x7B, 0xBD, 0x77, 0x82, 0xC2, 0x31, 0x1B,
0x2E, 0x7F, 0x1D, 0xE7, 0x10, 0x1E, 0xB3, 0x48, 0xF9, 0xCE, 0xF7, 0xC2, 0x24, 0x2D, 0x54, 0x0A,
0xDE, 0x1C, 0xFD, 0xCF, 0x0B, 0x7A, 0xEA, 0x0E, 0x8B, 0xCA, 0x4E, 0x40, 0x52, 0x1D, 0x9A, 0x5F,
0xEC, 0xCC, 0xB8, 0xB2, 0xF9, 0xD2, 0xA0, 0xD2, 0x97, 0x10, 0xF3, 0x36, 0x70, 0x10, 0xF7, 0x30,
0x41, 0x8D, 0x18, 0x70, 0xBC, 0xA0, 0xD3, 0xD1, 0x77, 0xCC, 0x0E, 0xF2, 0xD3, 0xC4, 0x96, 0x8D,
0x7F, 0x77, 0x40, 0xFC, 0xB6, 0xEE, 0x2B, 0x60, 0xB2, 0x3D, 0xDB, 0xA1, 0x30, 0x02, 0x48, 0xD3,
0xB9, 0x58, 0x13, 0xD1, 0xDA, 0xB3, 0x15, 0xF1, 0x56, 0x62, 0x28, 0x34, 0x63, 0xDD, 0x0B, 0xF8,
0x44, 0xA7, 0x1C, 0xC3, 0xCE, 0xC8, 0x2C, 0x17, 0xEF, 0xC2, 0xE8, 0xCE, 0x1D, 0x9C, 0xD3, 0x28,
0x5E, 0x1E, 0xA8, 0x99, 0xEB, 0x21, 0xC2, 0x03, 0xC4, 0x33, 0xEB, 0x1B, 0x5E, 0x9D, 0xDE, 0x13,
0xD4, 0xE9, 0xF5, 0xB3, 0xF5, 0x2D, 0x01, 0x2F, 0x5E, 0xC5, 0xED, 0x59, 0xD5, 0xB6, 0x7C, 0x8B,
0x36, 0x75, 0xA5, 0x1F, 0x33, 0x67, 0x72, 0xB7, 0xFE, 0xDD, 0x57, 0x4F, 0x45, 0x80, 0x2A, 0xFC
            
        #endregion
        };
        


        //Set DWORD At
        private void SetDWAt(ref byte[] content, uint pos, uint val) {
            byte[] DW = BitConverter.GetBytes(val);
            if (!BitConverter.IsLittleEndian)
                Array.Reverse(DW, 0, 4);
            DW.CopyTo(content, pos);
        }

        //Get DWord At
        public uint GetDW(byte[] Arr, uint Pos) {
            byte[] DW = new byte[] { Arr[Pos], Arr[Pos + 1], Arr[Pos + 2], Arr[Pos + 3]};
            if (!BitConverter.IsLittleEndian)
                Array.Reverse(DW, 0, 4);
            return BitConverter.ToUInt32(DW, 0);
        }
        
    }
}
